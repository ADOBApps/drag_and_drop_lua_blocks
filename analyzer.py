"""
Block Analyzer - Code generation and validation logic
This file is part of Quantum Analysis Helper.
Quantum Analysis Helper is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Quantum Analysis Helper is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Copyright (C) [2026] Acxel David Orozco Baldomero
"""

from typing import Dict, Any, List
import re


class BlockAnalyzer:
    """Analyze blocks and generate Lua code"""
    
    def __init__(self):
        self.entry_points = []
        self.blocks = []
    
    def analyze_blocks(self, blocks: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze block structure and generate code"""
        results = {
            'valid': True,
            'errors': [],
            'warnings': [],
            'code': '',
            'metadata': {}
        }
        
        try:
            # Find entry points
            self.entry_points = [b for b in blocks if b.get('type') == 'event']
            
            if not self.entry_points:
                results['warnings'].append("No entry points found. Add 'On Start' or similar event blocks.")
            
            # Generate code from entry points
            code = self._generate_code_from_blocks(blocks)
            results['code'] = code
            
            # Collect metadata
            results['metadata'] = {
                'total_blocks': len(blocks),
                'event_blocks': len([b for b in blocks if b.get('type') == 'event']),
                'control_blocks': len([b for b in blocks if b.get('type') == 'control']),
                'function_blocks': len([b for b in blocks if b.get('type') == 'function']),
                'entry_points': len(self.entry_points)
            }
            
        except Exception as e:
            results['valid'] = False
            results['errors'].append(f"Analysis error: {str(e)}")
        
        return results
    
    def _generate_code_from_blocks(self, blocks: List[Dict[str, Any]]) -> str:
        """Generate Lua code from blocks"""
        code = "-- Generated by Drag-and-Drop Lua Blocks\n\n"
        
        # Add entry point code
        for block in blocks:
            if block.get('type') == 'event':
                block_code = block.get('lua_code', '')
                if block_code:
                    code += f"{block_code}\n"
        
        # Add other blocks
        for block in blocks:
            if block.get('type') != 'event':
                block_code = block.get('lua_code', '')
                if block_code:
                    code += f"{block_code}\n"
        
        return code
    
    def validate_code(self, code: str) -> Dict[str, Any]:
        """Validate generated Lua code"""
        results = {
            'valid': True,
            'errors': [],
            'warnings': [],
            'suggestions': []
        }
        
        # Basic syntax checks
        if not code.strip():
            results['valid'] = False
            results['errors'].append("Empty code")
            return results
        
        # Check for common Lua syntax issues
        lines = code.split('\n')
        for i, line in enumerate(lines, 1):
            line = line.strip()
            
            # Check for unclosed statements
            if line.startswith('if ') and 'then' not in line and 'end' not in line:
                results['warnings'].append(f"Line {i}: if statement might be missing 'then' or 'end'")
            
            if line.startswith('function ') and 'end' not in code[code.find(line):]:
                results['warnings'].append(f"Line {i}: function might be missing 'end'")
        
        # Check for print statements (good practice)
        if 'print(' not in code and 'print "' not in code:
            results['suggestions'].append("Consider adding print statements for debugging")
        
        return results
    
    def optimize_code(self, code: str) -> str:
        """Apply basic optimizations to Lua code"""
        if not code:
            return code
        
        optimized = code
        
        # Remove consecutive empty lines
        optimized = re.sub(r'\n\s*\n\s*\n', '\n\n', optimized)
        
        # Remove trailing whitespace
        optimized = '\n'.join(line.rstrip() for line in optimized.split('\n'))
        
        return optimized